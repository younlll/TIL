* 컴퓨터 구조 중 CPU 내부에서 산술/논리 연산장치(ALU, Arithmetic Logic Unit)으로 연산이 이루어진다
* ALU는 가산기로 이루어져 있으며 모든 연산을 2진수로 처리한다
* 가산기로 이루어져 있다보니 덧셈을 기반으로 사칙연산이 이루어진다
* 이러한 이유로 `보수는 음의 정수를 위해 고안`이된 것이다

</br>

### n진수, n의 보수법
* **n진수는 n의 보수법으로 나타낼 수 있다**
  * 2진수는 2의 보수법, 10진수는 10의 보수법

* n의 보수법은 각 자리의 숫자 + X를 통해 n을 만들수 있는 수를 찾는다고 생각하면 된다
  * 예를들어, 10진수에서 37의 10의 보수는
    1) 일의 자리 7을 10으로 만들기 위해서는 **3**이 필요하며 3을 더하면 10이되며 **올림**이 발생한다
    2) 일의 자리에서 올림이 발생했으므로 3 + 1 = 4가 되고 4를 10으로 만들수 있는 숫자는 6이된며 여기서 발생한 올림은 버린다
    3) 이렇게 10진수에서 `37의 10의 보수 63`을 찾을 수 있다</br></br>

  * 여기서 10진수에서 37의 9의 보수를 찾아보자
    1) 각 자릿수를 9로 만들수 있는 수를 찾으면 된다
    2) 일의 자리가 7이므로 9를 만들수 있는 수는 2가 된다
    3) 십의 자리가 3이므로 9를 만들수 있는 수는 6이된다
    4) 따라서 **37의 9의 보수는 62**가 된다
    5) 여기서 알수 있는건 37의 10의 보수는 9의 보수 +1과 같다는 것이다
    6) 따라서 `10의 보수는 9의 보수 +1과 같다`를 알 수 있다

</br>

* 위 예시를 통해서 컴퓨터의 사칙연산을 위한 `2진수의 2의 보수는 1의 보수 +1`을 통해 구할 수 있다는 것을 찾을 수 있다
* 이것을 바탕으로 -127을 계산 해보면
  1) 127 → 01111111(2) ⇒ 여기서 8번째 위치에 있는 숫자 0은 MSB로 최상위 비트이며 부호를 나타낸다(0:양수 / 1:음수)
  2) 1의 보수를 취하면 → 00000000(2) ⇒ 여기서 1의 보수는 **11111111과 XOR연산을 통해 얻을수 있다**
  3) 구하고 싶은 건 1의 보수가 아니라 2의 보수이다
  4) 2의 보수는 1의 보수 +1이므로 00000001(2)가 된다
  5) 마지막으로 음수이기 때문에 MSB를 1로 표기해주면 10000001(2)이 된다
  6) 따라서, -127은 100000001(2)이 된다


* 연산시 알아야할 추가적인 사항으로는
* **1의 보수는 carry(올림) 발생 시 +1**
* **2의 보수는 carry(올림) 발생 시 버림**
* 두 보수 모두 carry(올림)이 발생하지 않는 경우에는 다시 보수를 취해준다

</br>

### 10 - 7 = 3
* 연산에 사용될 숫자를 2진수로 변환
  * 10 → 1010(2)
  * 7 → 0111(2)
* 연산을 하면 10 - 7은 **10 + (-7)과 같은 연산**이고 **1010(2) - 0111(2) = 1010(2) + (- 0111(2))** 이 된다
* -0111(2)는 음수이므로 보수를 통해 계산해주면
* 0111(2)의 1의 보수는 1000(2)이고
* 2의 보수는 1의 보수 +1이므로 1000(2) +1 = 1001(2)이 된다
* 이제 덧샘을 계산하면
* 1010(2) + 1001(2) = **1**0011(2)가 되며 `1+1 = 2가되어 0으로 표기되고 1 carry(올림)가 발생했다`
* 위에서 `2의 보수는 carry(올림)이 발생하면 버리기`로 했으므로
* 결과적으로 계산은 `1010(2) + 1001(2) = 0011(2) → 10진수로 바꾸면 3`이 되어서 뺄샘이 정확히 된 것을 알 수 있다

</br>

### 7 - 10 = -3
* 연산에 사용될 숫자를 2진수로 변환
  * 7 → 0111(2)
  * 10 → 1010(2)
* 연산을 하면 7 - 10은 **7 + (-10)과 같은 연산**이고 **0111(2) - 1010(2) = 0111(2) + (- 1010(2))** 이 된다
* -1010(2)는 음수이므로 보수를 통해 계산해주면
* 1010(2)의 1의 보수는 0101(2)이고 이것을 2의 보수로 바꾸어 주면
* 2의 보수는 1의 보수 +1이므로 0101(2) + 1 = 0110(2)이 된다
* 0111(2) + 0110(2) = 1101(2)가 되고 carry(올림)이 발생하지 않았다
* `carry(올림)이 발생하지 않으면 구한 수의 보수를 다시 구한다`라고 했으므로
* 1101(2)의 1의 보수는 0010(2)가 되고 이것을 2의 보수로 바꾸어주면
* 2의 보수는 1의 보수 +1이므로 0010(2) + 1 = **0011(2)** 가 되어서 결론적으로 **-0011(2)** 가 됨을 알 수 있다
