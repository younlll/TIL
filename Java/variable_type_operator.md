#### 변수
* 하나의 값을 저장할 수 잇는 메모리 공간을 말하며 이 메모리 주소에 붙여진 이름이 변수명인 것이다
* 리터럴(literal) : 소스코드 내에 직접 입력된 값
* 변수들은 선언된 중괄호{} 블럭 안에서만 사용이 가능하다

## 데이터 타입
### 정수타입
#### byte type
* byte 타입은 바이너리 데이터를 처리할 때 주로 사용된다
* 범위 : -2^7 ~ 2^7 - 1 (0포함하므로 2^7 - 1까지 이다)
* 가장 앞에 있는 bit(최상위 비트/MSB:Most Significant Bit)는 부호(+/-)를 결정
* 프로그램 실행중에 저장할 수 있는 값의 범위를 초과하ㅏ면 최소값부터 다시 반복 저장된다

#### char type
* 유니코드를 저장하기 위한 2byte 크기를 같는 데이터 타입이다

      char c1 = 'A';
      char c2 = 65;
      char c3 = '\u0041';
      3가지 경우 모두 알파벳 A라는 문자의 결과를 갖는다

#### short type
* `2byte`로 표현되는 정수값을 저장할 수 있는 데이터 타입

#### int type
* `4byte`로 표현되는 정수값을 저장할 수 있는 데이터 타입

      int var1 = 10;  // -> 10진수
      int var2 = 012; // -> 8진수
      int var3 = 0xA; // -> 16

#### long type
* `8byte`로 표현되는 정수값을 저장할 수 있는 데이터 타입

</br>

### 실수 타입
* 실수는 부동소수점 방식으로 저장된다
* float : 부호(1bit) + 지수(8bit) + 가수(23bit) = 32bit = 4byte
* double : 부호(1bit) + 자수(11bit) + 가수(52bit) = 64bi = 8byte

</br>

### 논리 타입(boolean)
* 1byte로 표현되는 논리값(true/false)을 저장할 수 있는 데이터 타입


#### 타입변환
* byte(1) < short(2) < int(4) < long(8) < float(4) < double(8)
  ##### 1. 자동 타입 변환
    * 큰 크기의 타입 <- 작은 크기의 타입
    * 연산에서 서로 다른 타입의 피연산자가 있을 경우 두 피연산자 중 크기가 큰 타이븡로 자동 변환된 후 연산 수행
  ##### 2. 강제 타입 변환
    * 작은 크기의 타입 <- (작은 크기의 타입)큰 크기의 타입
    * 원래 값이 보존되지 않는다

## 연산자
* 단항 연산자: ++x, x--
* 이항 연산자: x + y
* 삼항 연산자: x > y ? "x" : "y"

### 부호 연산자
      int x = +100;
      int y = -100;
      double d1 = +3.14;

### 증감 연산자
      num++;
      num--;
      ++num;
      --num;

### 논리 부정 연산자
* 연산자는 `!`를 사용
* true를 false로 false를 true로 변경

### 비트 반전 연산자
* 연산자는 `~`를 사용
* 비트 반전 연산자 상출 타입은 int타입이 된다
* 비트 반전 연산자 사용 후, +1을 하면 부호가 반대인 정수를 얻을 수 있다

### 산술 연산자
* +, -, *, /, %
* 산술 연산시, 산출값이 산출 타입으로 충분히 표현 가능한 범위의 숫자인지 확인 해야한다.
* 그렇지 않으면 `오버플로우`가 발생하고 쓰레기 값이 들어가기 때문이다
* 정확한 계산은 정수를 사용하는 것이 좋다
* 왜냐하면 float과 double 타입은 이진 포맷의 가수를 사용하기 때문에 0.1을 정확히 표현할 수 없어 근사치로 처리하기 때문에
* 정확한 계산이 어렵다

### NaN과 Infinity
* 5 / 0 이나 5 % 0은 ArithmeticException 예외가 발생한다
* ArithmeticException에 대한 예외처리를 하면

```java
try {
  int z = x % y;
} catch(ArithmeticException e) {  // y가 0일 경우, ArithmeticException 발생에 대한 예외처리
  throw e;
}
```

* 실수타입으로 나누게 되는 경우 ArithmeticException이 발생 하는 것이 아니라
* 나누기(/) 연산자는 Infinity 값을 갖고
* 나머지(%) 연산자는 NaN 값을 갖는다
* 이런 경우, 계속 연산이 가능하며 해당 값들을 갖고 이후 연산을 계속 한다면 Infinity와 NaN으로 연산이 되어 원하는 값을 얻지 못한다
* 코드를 작성하면서 Infinity 또는 NaN인지 확인을 하도록 해야한다

```java
if(Double.isInfinite(num) || Double.isNaN(num)) {
  System.out.println("값 산출 불가");
} else {
  System.out.println(num + 2);
}
```

* 이것 외에도 입력부터 NaN이 들어올 수 있으므로 isNaN() 메소드를 통해 NaN 검사후 연산을 수행해야한다


### 문자열 연결 연산자
* `+`연산자를 통해 문자열을 서로 연결 시켜준다

      String str1 = "JDK" + 11; // JDK11
      String str2 = str1 + "특징";  // JDK11특징

### 비교 연산자
* 동등비교 : ==, !=
* 크기비교 : >, >=, <, <=

#### String
* String은 참조 타입으로 동등비교 시 주의해야한다
* 문자열 리터럴이 동일하다면 동일한 String 객체를 참조하도록 한다

```java
String str1 = "Youn";
String str2 = "Youn";
String str3 = new String("Youn");
```

      str1 == str2 -> true
      str1 == str3 -> false

* str1과 str2는 "Youn"이라는 문자열로 동일하므로 메모리 구조 중 Heap영역에 할당된 같은 객체의 주소값을 갖게 된다
* str3은 객체 생성 연산자인 new로 생성한 새로운 String 객체이므로 새로운 객체의 주소값을 갖게된다
* 그래서 str3과 동등비교를 하게 된다면 값이 같지 않다라는 결과를 얻게 되는 것이다
* 결과를 보면 비교 연산자로는 객체가 갖고 있는 문자열이 같은지 비교하는 것이 아니라 객체의 주소값을 비교하는 것을 알 수 있다
* 문자열을 비ㄱ하기 위해서는 `equals()` 메소드를 사용해야 한다

      str1.equals(str2) -> true
      str1.equals(str3) -> true

### 논리 연산자
* 논리연산자의 피연산자는 boolean만 사용 가능하다
* 논리곱(AND) : &&, &
* 논리합(OR) : ||, |
* 배타적 논리합(XOR) : ^
* 논리부정(NOT) : !

### 비트 연산자
* bit단위로 연산을 하는 것으로 0과 1이 피연산자가 된다
* 그러므로 0과 1의 표현이 가능한 정수타입만 연산이 가능하다(실수 타입은 비트연산을 할 수 없다)

#### 비트 논리 연산자
* 논리곱(AND) : &
* 논리합(OR) : |
* 배타적 논리합(XOR) : ^
* 논리부정(NOT) : !
* 비트 연산자는 피연산자를 int타입으로 자동 타입 변환한 후 연산을 수행한다

#### 비트 이동 연산자
|연산식|설명|
|---------|-------|
|a << b|정수a의 각 비트를 b만큼 왼쪽으로 이동하고 빈자리는 0으로 채워진다|
|a >> b|정수a의 각 비트를 b만큼 오른쪽으로 이동 후, 빈자리는 정수a의 부호비트와 같은 값으로 채워진다|
|a >>> b|정수a의 각 비트를 b만큼 오른쪽으로 이동하고 빈자리는 0으로 채워진다|

### 삼항 연산자
* 조건식 ? 조건식이 ture인 경우 값 또는 연산식 : 조건식이 false인 경우 값 또는 연산식

</br>

#### Reference
> '이것이 자바다 - 신용권지음'
