# JVM
* Java코드를 컴파일 해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계언어로 바꿔 실해이켜주는 역할
---

### JVM의 구성
**1. Class Loader**</br>
  * .java 파일을 컴파일하면 .class(바이트코드) 파일이 생성된다
  * 이렇게 생성된 클래스 파일들을 엮어 JVM이 운영체제부터 얻은 메모리 영역인 Runtime Data Area에 적재

**2. Execution Engine**</br>
  * 메모리에 적재된 class파일들을 기계언어로 변경해 명령어 단위로 실행

**3. Garbage Collector**</br>
  * Heap메모리 영역에 적재된 객체들 중 참조되지 않는 객체들을 탐색 후 제거하는 역할
  * GC가 수행되는 동안 GC를 수행하는 쓰레드 이외의 모든 쓰레드는 일시정지

**4. Runtime Data Area**</br>
  * 메모리 영역으로 필요한 데이터들이 적재되는 공간</br>
    1) Method Area
        - class, method, type의 정보와 static, final class변수 등이 생성
    2) Heap Area
        - new키워드로 생성된 객체와 배열이 생성되는 영역
        - Method Area에 로드된 클래스만 가능
        - Garbage Collector가 수행되는 영역
    3) Stack Area
        - 지역변수, 파라미터, 리턴값, 연산에 사용되는 임시 값등이 생성되는 영역
    4) PC Register
        - 쓰레드가 생성될 때마다 생성되는 영역 = Program Counter
        - 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역
    5) Native method stack
        - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역
---
### Garbage Collector
* 프로그램이 동적으로 할당된 메모리 영역 중 필요없게 된 영역을 해제하는 기능
1. 포인터 추적방식
    1. 표시하고 쓸기
        - 영역표시를 위해 각 메모리 할당 시 1비트의 메모리를 남겨둔다
        - 모든 변수가 가리키는 영역을 사용중으로 표시하고 그 영영이 가리키는 다른 영역도 사용중으로 표시
        - 접근이 불가능한 메모리영역을 쓸기 단계에서 해제한다
        - 표시 시, 전체 시스템의 실행을 정지해야하고 전체 메모리 영역을 검사해야한다는 점에서 프로그램 성능 저하가 발생 할 수 있다
    2. 삼색표기법
        - 말 그대로 3가지(흰색, 회색, 검정색) 색으로 정보를 나타냄
        - 회색으로 표시된 객체 중 하나를 검정색으로 표시하고 이 객체가 가리키는 모든 객체를 회식으로 표시
        - 회색이 남지 않을 때까지 반복한다
        - 남아 있는 흰색 객체는 접근이 불가능한 객체로 해제한다
    3. 객체이동기법
        - 해제되지 않은 객체를 다른 영역으로 복사하는 기법
